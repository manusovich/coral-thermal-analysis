#!/usr/bin/env python3
"""MJPEG stream for Home Assistant (low FPS)."""
from __future__ import annotations

import argparse
import threading
import time
from http.server import BaseHTTPRequestHandler, HTTPServer

import cv2


def read_cpu_temp_c() -> float | None:
    for path in ("/sys/class/thermal/thermal_zone0/temp", "/sys/class/thermal/thermal_zone1/temp"):
        try:
            with open(path, "r", encoding="utf-8") as f:
                raw = f.read().strip()
            if raw.isdigit():
                return int(raw) / 1000.0
        except OSError:
            continue
    return None


class MJPEGHandler(BaseHTTPRequestHandler):
    server_version = "CoralCamera/0.1"

    def do_GET(self):
        if self.path not in ("/", "/stream", "/mjpeg"):
            self.send_error(404)
            return
        self.send_response(200)
        self.send_header("Content-Type", "multipart/x-mixed-replace; boundary=frame")
        self.end_headers()

        while True:
            with self.server.frame_lock:
                frame = self.server.latest_jpeg
            if frame is None:
                time.sleep(0.05)
                continue
            try:
                self.wfile.write(b"--frame\r\n")
                self.wfile.write(b"Content-Type: image/jpeg\r\n")
                self.wfile.write(f"Content-Length: {len(frame)}\r\n\r\n".encode("utf-8"))
                self.wfile.write(frame)
                self.wfile.write(b"\r\n")
                time.sleep(self.server.stream_interval)
            except BrokenPipeError:
                break


class MJPEGServer(HTTPServer):
    def __init__(self, server_address, handler, stream_interval: float):
        super().__init__(server_address, handler)
        self.latest_jpeg = None
        self.frame_lock = threading.Lock()
        self.stream_interval = stream_interval


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--camera", default="/dev/video0")
    parser.add_argument("--width", type=int, default=640)
    parser.add_argument("--height", type=int, default=480)
    parser.add_argument("--fps", type=int, default=10)
    parser.add_argument("--output-fps", type=float, default=1.0)
    parser.add_argument("--host", default="0.0.0.0")
    parser.add_argument("--port", type=int, default=8080)
    parser.add_argument("--agc", action="store_true")
    parser.add_argument("--max-seconds", type=float, default=0.0)
    args = parser.parse_args()

    cap = cv2.VideoCapture(args.camera)
    if not cap.isOpened():
        raise SystemExit(f"Unable to open camera: {args.camera}")
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, args.width)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, args.height)
    cap.set(cv2.CAP_PROP_FPS, args.fps)

    start_time = time.time()
    last_stat_time = start_time
    last_cpu_pct = 0.0
    last_temp_c = None
    last_emit_time = 0.0
    emit_interval = 1.0 / max(0.1, args.output_fps)

    server = MJPEGServer((args.host, args.port), MJPEGHandler, stream_interval=emit_interval)

    def serve():
        server.serve_forever()

    threading.Thread(target=serve, daemon=True).start()
    print(f"Streaming MJPEG at http://{args.host}:{args.port}/stream")

    while True:
        ok, frame = cap.read()
        if not ok:
            break

        if args.agc:
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            gray = cv2.equalizeHist(gray)
            frame = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)

        now = time.time()
        if now - last_stat_time >= 2.0:
            last_stat_time = now
            last_cpu_pct = (time.process_time() / max(1e-6, now - start_time)) * 100.0
            last_temp_c = read_cpu_temp_c()
            if last_temp_c is None:
                print(f"CPU {last_cpu_pct:.1f}% TEMP NA", flush=True)
            else:
                print(f"CPU {last_cpu_pct:.1f}% TEMP {last_temp_c:.1f}C", flush=True)

        ts = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(now))
        temp_str = "NA" if last_temp_c is None else f"{last_temp_c:.1f}C"
        overlay = f"{ts}  TEMP {temp_str}  CPU {last_cpu_pct:.1f}%"
        cv2.putText(
            frame,
            overlay,
            (6, 14),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.4,
            (0, 0, 0),
            1,
            cv2.LINE_AA,
        )

        if now - last_emit_time >= emit_interval:
            last_emit_time = now
            ok, buf = cv2.imencode(".jpg", frame)
            if ok:
                with server.frame_lock:
                    server.latest_jpeg = buf.tobytes()

        if args.max_seconds and (now - start_time) >= args.max_seconds:
            break

    cap.release()
    server.server_close()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
